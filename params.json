{"name":"Yopt","tagline":"A Scala inspired gem that introduces Options to Ruby while aiming for an idiomatic API","body":"# Yopt\r\n\r\nA [Scala](http://www.scala-lang.org/api/current/index.html#scala.Option) inspired gem that introduces `Option`s to Ruby while aiming for an idiomatic API.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'yopt'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install yopt\r\n\r\n## Basic usage\r\n\r\nThe Option type models the possible absence of a value. It lets us deal with the uncertainty related to such a value being there without having to resort to errors or conditional blocks.\r\n\r\nInstances of Option are either an instance of `Yopt::Some` - meaning the option contains a value - or the object `Yopt::None` - meaning the option is *empty*.\r\n\r\n```ruby\r\nrequire 'yopt'\r\n\r\nsome = Yopt::Some.new(42)\r\nnone = Yopt::None\r\n```\r\n\r\nWe can access and manipulate the optional value by passing a block to `Option#map`.\r\n\r\n```ruby\r\nsome.map {|value| value + 2} # returns Some(44)\r\nnone.map {|value| value + 2} # returns None\r\n```\r\n\r\nWhen we are not interested in the result of a computation on the optional value, it is a good practice to use `Option#each` rather than `Option#map`. That will make our intention clearer.\r\n\r\n```ruby\r\nsome.each {|value| puts value} # prints 42\r\nnone.each {|value| puts value} # does not print anything\r\n```\r\n\r\nWe can safely retrieve the optional value by passing a default value to `Option#get_or_else`\r\n\r\n```ruby\r\nsome.get_or_else {0} # returns 42\r\nnone.get_or_else {0} # returns 0\r\n```\r\n\r\nNotice how we are passing a block rather than an argument. This makes the evaluation of the default value lazy. In other words the block will only be evaluated if the caller in None.\r\n\r\nThis gives us the possibility to react in a special way to a None value without breaking the API fluency, e.g.\r\n\r\n```ruby\r\nopt.each {|v| do_something_with(v)}.get_or_else {log_failure}\r\n```\r\n\r\nWe can also filter the optional value depending on how it evaluates against a block via `Option#select`\r\n\r\n```ruby\r\nsome.select {|value| value < 0} # returns None\r\nnone.select {|value| value < 0} # returns None\r\nsome.select {|value| value > 0} # returns Some(42)\r\n```\r\n\r\nWe can easily turn any object into an Option by means of `Option.call` - aliased to `Option[]` for convenience.\r\nFor instance, this is useful when dealing with functions that might return `nil` to express the absence of a result.\r\n\r\n```ruby\r\nYopt::Option[nil] # returns None\r\nYopt::Option[42] # returns Some(42)\r\n```\r\n\r\n\r\nA combination of the few methods just introduced already allows us to implement some pretty interesting logic. Checkout `basics.rb` in the docs folder to get some inspiration.\r\n\r\n## Why opt?\r\n\r\nUsing `Option`s reduces the amount of branching in our code and lets us deal with exceptional cases in a seamless way. No more check-for-nil, no more `rescue` blocks, just plain and simple data transformation.\r\n\r\nIt also makes our code safer by treating *the absence of something* like a fully fledged object, and enables us to use the Null Object Pattern everywhere we want without the overhead of having to write specialized Null-type classes for different classes.\r\n\r\n## Advanced Usage\r\n### #reduce\r\nGiven an Option `opt`, a value `c` and a lambda `f`,\r\n```\r\nopt.reduce(c, &f)\r\n```\r\nreturns `c` if `opt` is `None`, and `f.(c, opt)` otherwise.\r\n\r\nThis is a shortcut to\r\n```\r\nopt.map{|v| f.(c,v)}.get_or_else {c}`\r\n```\r\n\r\n\r\n### #flatten and #flat_map\r\nWhen working with functions returning `Option`, we might end up dealing with nested options...\r\n```ruby\r\nmaybe_sqrt = lambda {|x| Yopt::Option[x >= 0 ? Math.sqrt(x) : nil]}\r\nmaybe_increment = lambda {|x| Yopt::Option[x > 1  ? x + 1 : nil]}\r\n\r\nmaybe_sqrt.(4).map {|v| maybe_increment.(v)} # Some(Some(3.0))\r\nmaybe_sqrt.(1).map {|v| maybe_increment.(v)} # Some(None)\r\n```\r\n\r\nUsually, this is not what we want, so we call `Option#flatten` on the result\r\n```ruby\r\nmaybe_sqrt.(4).map {|v| maybe_increment.(v)}.flatten # Some(3.0)\r\nmaybe_sqrt.(1).map {|v| maybe_increment.(v)}.flatten # None\r\n```\r\n\r\n`Option#flat_map` combines the two calls into one\r\n\r\n```ruby\r\nmaybe_sqrt.(4).flat_map {|v| maybe_increment.(v)} # Some(3.0)\r\nmaybe_sqrt.(1).flat_map {|v| maybe_increment.(v)} # None\r\n```\r\n\r\nA difference to keep in mind is that `#flatten` will raise an error if the wrapped value does not respond to `#to_ary`\r\n```ruby\r\nYopt.Option[42].flatten # raises TypeError: Argument must be an array-like object. Found Fixnum\r\n```\r\nwhereas #flat_map behaves like #map when the passed block does not return an array-like value\r\n```ruby\r\nYopt.Option[42].flat_map{|v| v} # returns Some(42)\r\n```\r\n\r\n\r\n### #zip\r\nWhen dealing with a set of `Option` instances, we might want to ensure that they are all defined - i.e. not __empty__ - before continuing a computation...\r\n```ruby\r\nemail_opt.each(&send_pass_recovery) unless (email_opt.empty? or captcha_opt.empty?)\r\n```\r\n\r\nWe can avoid `empty?` checks by using `Option#zip`\r\n```ruby\r\nemail_opt.zip(captcha_opt).each{|(email,_)| send_pass_recovery(email)}\r\n```\r\n\r\n`Option#zip` returns `None` if any of the arguments is `None` or if the caller is `None`\r\n```ruby\r\nYopt::None.zip Option[42] # None\r\nOption[42].zip Yopt::None # None\r\nOption[42].zip Option[0], Yopt::None, Option[-1] # None\r\n```\r\n\r\nWhen both the caller and all the arguments are defined then `zip` collects all the values in an Array wrapped in a `Yopt::Some`\r\n\r\n```ruby\r\nOption[42].zip Option[0], Option[\"str\"] # Some([42, 0, \"str\"])\r\n```\r\n\r\n\r\n### #grep\r\nWe often find ourselves filtering data before applying a transformation...\r\n\r\n```ruby\r\nopt.filter {|v| (1...10).include? v}.map {|v| v + 1}\r\n```\r\n\r\nIn this scenario, `Option#grep` can sometimes make the code more concise\r\n\r\n```ruby\r\nopt.grep(1...10) {|v| v + 1}\r\n```\r\n\r\n`Option#grep` supports lambdas as well\r\n\r\n```ruby\r\nis_positive = lambda {|x| x > 0}\r\n\r\nopt.grep(is_positive) {|v| Math.log(v)}\r\n# is equivalent to\r\nopt.filter(&is_positive).map {|v| Math.log(v)}\r\n```\r\n\r\n\r\n## Haskell Data.Maybe cheat sheet\r\n\r\nSome (None?) might enjoy a comparison with Haskell's [Maybe](https://hackage.haskell.org/package/base/docs/Data-Maybe.html). Here is how the Data.Maybe API translate to Yopt.\r\n```ruby\r\nmaybe default f opt     -> opt.map(&f).get_or_else {default}\r\nisJust opt              -> not opt.empty?\r\nisNothing opt           -> opt.empty?\r\nfromJust opt            -> opt.get\r\nfromMaybe default opt   -> opt.get_or_else {default}\r\nlistToMaybe list        -> Option.ary_to_type list\r\nmaybeToList opt         -> opt.to_a\r\ncatMaybes listOfOptions -> listOfOptions.flatten\r\nmapMaybe f list         -> list.flat_map &f\r\n```\r\n\r\n\r\n## Development\r\n\r\nAfter checking out the repo, run `bin/setup` to install dependencies. Then, run `rake test` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.\r\n\r\nTo install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).\r\n\r\n\r\n## Contributing\r\n\r\nBug reports and pull requests are welcome on GitHub at https://github.com/lbarasti/yopt. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the [Contributor Covenant](http://contributor-covenant.org) code of conduct.\r\n\r\n\r\n## License\r\n\r\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}